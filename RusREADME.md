# Алгоритм триангуляции Делоне методом заметающей прямой

Доброго времени суток!


В этой статье я подробно опишу алгоритм, который у меня получился в результате использования идеи "заметающей прямой" для
построения триангуляции Делоне на плоскости. В нем есть несколько идей, которые я нигде не встречал, когда читал статьи про триангуляцию.
Возможно, кто-то тоже найдет их необычными. Я постараюсь сделать все в лучших традициях и включить в рассказ следующие вещи: описание используемых структур данных, описание шагов алгоритма, доказательство корректности, временные оценки, а также сравнение с итеративным алгоритмом, использующим kD-дерево.


### Определения и постановка задачи
Говорят, что на множестве точек на плоскости задана триангуляция, если некоторые пары точек соединены ребром, а любая конечная грань в получившемся графе образует треугольник
<p><img src="../master/Pictures/triangulation.png" width="511" height="300"></p>


Триангуляцией Делоне называется такая триангуляция, в которой для любого треугольника верно, что внутри описанной около него окружности не находится точек из исходного множества.
<p><img src="../master/Pictures/Delaunay.png" width="508" height="300"></p>

Замечание: для заданного множества точек, в котором никакие 4 точки не находятся на одной окружности, существует ровно одна триангуляция Делоне


Пусть на множестве точек задана триангуляция. Будем говорить, что некоторое подмножество точек удовлетворяет условию Делоне, если триангуляция, ограниченная на это подмножество, является триангуляцией Делоне для него. 


Замечание: проверка условия Делоне для всех точек, образующих выпуклый четырехугольник в триангуляции, гарантирует то, что она является триангуляцией Делоне. 


Замечание 2: для выпуклого четырехугольника существует ровно 2 возможные триангуляции (одна из которых является триангуляцией Делоне)
<p><img src="../master/Pictures/4-gon.png" width="470" height="300"></p>


Замечание 3: для невыпуклых четырехугольников условие Делоне всегда выполнено. 


Задача собственно заключается в том, чтобы для заданного множества точек построить триангуляцию Делоне

### Описание алгоритма
Для начала введем следующее определение:


Пусть задана минимальная выпуклая оболочка (далее МВО) конечного множества точек (ребра, соединяющие некоторые из точек так, чтобы они образовывали многоугольник, содержащий все точки множества) и точка A, лежащая вне оболочки. Тогда точка плоскости называется видимой для точки А, если отрезок, соединяющий ее с точкой А, не пересекает МВО.
Ребро МВО называется видимым для точки А, если его концы видимы для А [картинка]. 


Замечание: контур триангуляции Делоне является МВО для точек, на которых построена.


Замечание 2: видимые ребра образуют цепочку


Думаю, здесь стоит сделать пару замечаний, чтобы понять, как хранить триангуляцию. Есть некоторые стандартные способы, неплохо описанные в книге Скворцова [1]. Ввиду специфики алгоритма, я предложу свой вариант. Так как хочется проверять 4-угольники на условие Делоне, то рассмотрим их строение. Каждый 4-угольник в триангуляции представляет из себя 2 треугольника, имеющих общее ребро. У каждого ребра есть ровно 2 треугольника, прилегающих к нему. Таким образом, каждый четырехугольник в триангуляции порождается ребром и двумя вершинам, находящимися напротив ребра в прилегающих треугольниках [картинка]. Так как по ребру и двум вершинам восстанавливаются два треугольника и их смежность, то по всем таким структурам мы сможем восстановить триангуляцию. Предлагается хранить их в множестве и выполнять поиск по ребру (упорядоченной паре вершин).




Приступим к алгоритму:

Идея заметающей прямой заключается в том, что все точки сортируются, а затем по очереди обрабатываются

1) Отсортируем все точки вдоль некоторой прямой (для простоты по координате х)

2) Построим треугольник на первых 3 точках

Далее для каждой следующей точки будем выполнять шаги, сохраняющие инвариант, что имеется триангуляция Делоне для уже добавленных точек и, соответственно, МВО для них.

3) Добавим треугольники, образованные видимыми ребрами и самой точкой (то есть добавим ребра из рассматриваемой точки во все концы видимых ребер)

4) Проверим на условие Делоне все четырехугольники, порожденные видимыми ребрами. Если где-то условие не выполнилось, то перестроим триангуляцию в четырехугольнике (напоминаю, что их всего две) и рекурсивно запустим проверку для четырехугольников, порожденных ребрами текущего четырехугольника (ибо только в них после изменения условие Делоне могло нарушиться) [гифка]


Замечание: в шаге (4) при рекурсивном запуске можно не проверять четырехугольники, порожденные ребрами, исходящими из рассматриваемой на данной итерации точки (их всегда два из четырех), ибо они являются невыпуклыми. Далее будем считать, что при каждом перестроении выполняется только 2 рекурсивных запуска


Осталось понять, как эффективно находить видимые ребра. Заметим, что предыдущая добавленная точка S находится в МВО на текущей итерации, так как имеет наибольшую координату х, а также видима для текущей точки. Тогда, замечая, что концы видимых ребер образуют непрерывную цепочку видимых точек, мы можем идти от точки S в обе стороны по МВО и собирать ребра, пока они видимы (видимость ребра проверяется с помощью векторного произведения). Таким образом удобно хранить МВО как двусвязный список, на каждой итерации удаляя видимые ребра и добавляя 2 новых из рассматриваемой точки [картинка]


### Корректность алгоритма


Чтобы доказать корректность алгоритма, достаточно доказать сохранение инварианта в шагах (3) и (4). 


После шага (3), очевидно, получится некоторая триангуляция текущего множества точек. 


В процессе выполнения шага (4) все четырехугольники, не удовлетворяющие условию Делоне, находятся в стеке рекурсии (следует из описания), а значит, по окончании шага (4) все четырехугольники удовлетворяют условию Делоне, то есть действительно построена триангуляция Делоне. Тогда осталось доказать, что процесс в шаге (4) когда-нибудь закончится. Это следует из того, что все ребра, добавленные при перестроении, исходят из текущей рассматриваемой вершины  (то есть на шаге i их не больше, чем i - 1) и из того, что после добавления этих ребер мы не будем рассматривать четырехугольники, порожденные ими (см. предыдущее замечание), а значит, добавим не более одного раза.


### Временная сложность


В среднем на равномерном, нормальном распределениях алгоритм работает довольно неплохо (результаты приведены в табличке). Есть предположение, что время его работы составляет O( nlogn ). В худшем случае имеет место оценка O( n^2 ).


Давайте разберем время работы по частям и поймем, какие из них оказывают самое большое влияние на итоговое время


Для сортировки будем использовать оценку O( nlogn )


Для начала покажем, что время, суммарно затраченное на поиск видимых граней, есть O( n ). Заметим, что на каждой итерации мы находим все видимые ребра и еще 2 (первые не видимые) за линейное время. Более того, найденные видимые ребра больше никогда не попадут в МВО, так что их мы не найдем. Также в шаге (3) мы добавляем в МВО новые 2 ребра. Таким образом, всего в меняющейся на протяжении алгоритма МВО побывает не более 2 * n ребер, значит, и различных видимых ребер будет не более 2 * n. Еще мы найдем 2 * n ребер, не являющихся видимыми. Таким образом, в общей сложности найдется не более 4 * n ребер, что соответствует времени O( n ). 


Суммарное время на построение треугольников из шага (3) с уже найденными видимыми ребрами, очевидно, O( n ).


Осталось разобраться с шагом (4). Сначала заметим, что проверка условия Делоне и перестроение в случае его не выполнения являются довольно дорогими действиями (хоть и работают за O(1)). Только на проверку условия Делоне может уйти около 28 арифметических операций. Посмотрим на среднее количество перестроений в течение этого шага. Практические результаты на некоторых распределениях приведены ниже. По ним очень хочется сказать, что среднее количество перестроений растет с логарифмической скоростью, однако оставим это как лишь предположение. [картинка] Здесь еще хочется подметить, что от направления, вдоль которого производится сортировка, может сильно варьироваться среднее число перестроений. Так на миллионе равномерно распределенных на длинном низком прямоугольнике с отношением сторон 100000:1 это число варьируется от 1.2 до 24 (эти значения достигаются при сортировке данных по горизонтали и вертикали соответственно). Поэтому я вижу смысл выбирать направление сортировки произвольным образом (в данном примере при произвольном выборе в среднем получалось около 2 перестроений) или выбрать его вручную, если данные заранее известны.


Таким образом, основное время работы программы обычно уходит на шаг (4). Если же он выполняется быстро, то есть смысл задуматься над ускорением сортировки.

В худшем случае на i-ой итерации происходит i - 1 рекурсивный вызов в шаге (4), то есть, суммируя по всем i, получаем асимптотику в худшем случае O( n^2 ). Следующая картинка иллюстрирует красивый пример, на котором программа может работать долго


### Сравнение с итеративным алгоритмом построения триангуляции Делоне с использованием kD-дерева


Коротко опишу вышеуказанный алгоритм. При поступлении очередной точки мы с помощью kD-дерева (советую почитать про него где-нибудь, если вы не знаете) находим довольно близкий к ней уже построенный треугольник. Затем обходом в глубину ищем треугольник, в который попадает сама точка. Достаиваем ребра в вершины найденного треугольника и фактически выполняем шаг (4) из нашего алгоритма для новых четырехугольников. Так как точка может быть вне триангуляции, то для упрощения предлагается накрыть все точки большим треугольником (построить его заранее), это решит проблему.


