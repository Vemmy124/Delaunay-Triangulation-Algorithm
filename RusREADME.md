# Алгоритм триангуляции Делоне методом заметающей прямой

Доброго времени суток!


В этой статье я подробно опишу алгоритм, который у меня получился в результате использования идеи "заметающей прямой" для
построения триангуляции Делоне на плоскости. В нем есть несколько идей, которые я нигде не встречал, когда читал статьи про триангуляцию.
Возможно, кто-то тоже найдет их необычными. Я постараюсь сделать все в лучших традициях и включить в рассказ следующие вещи: описание используемых структур данных, описание шагов алгоритма, доказательство корректности, временные оценки, а также сравнение с итеративным алгоритмом, использующим kD-дерево.


### Определения и постановка задачи
Говорят, что на множестве точек на плоскости задана триангуляция, если некоторые пары точек соединены ребром, а любая конечная грань в получившемся графе образует треугольник [картинка]


Триангуляцией Делоне называется такая триангуляция, в которой для любого треугольника верно, что внутри описанной около него окружности не находится точек из исходного множества. 

Замечание: для заданного множества точек, в котором никакие 4 точки не находятся на одной окружности, существует ровно одна триангуляция Делоне


Пусть на множестве точек задана триангуляция. Будем говорить, что некоторое подмножество точек удовлетворяет условию Делоне, если триангуляция, ограниченная на это подмножество, является триангуляцией Делоне для него. 


Замечание: проверка условия Делоне для всех точек, образующих выпуклый четырехугольник в триангуляции, гарантирует то, что она является триангуляцией Делоне. 


Замечание 2: для выпуклого четырехугольника существует ровно 2 возможные триангуляции (одна из которых является триангуляцией Делоне)


Замечание 3: для невыпуклых четырехугольников условие Делоне всегда выполнено. 


Задача собственно заключается в том, чтобы для заданного множества точек построить триангуляцию Делоне

### Описание алгоритма
Для начала введем следующее определение:


Пусть задана минимальная выпуклая оболочка (далее МВО) конечного множества точек (ребра, соединяющие некоторые из точек так, чтобы они образовывали многоугольник, содержащий все точки множества) и точка A, лежащая вне оболочки. Тогда точка плоскости называется видимой для точки А, если отрезок, соединяющий ее с точкой А, не пересекает МВО.
Ребро МВО называется видимым для точки А, если его концы видимы для А [картинка]. 


Замечание: контур триангуляции Делоне является МВО для точек, на которых построена.


Замечание 2: видимые ребра образуют цепочку


Думаю, здесь стоит сделать пару замечаний, чтобы понять, как хранить триангуляцию. Есть некоторые стандартные способы, неплохо описанные в книге Скворцова [1]. Ввиду специфики алгоритма, я предложу свой вариант. Так как хочется проверять 4-угольники на условие Делоне, то рассмотрим их строение. Каждый 4-угольник в триангуляции представляет из себя 2 треугольника, имеющих общее ребро. У каждого ребра есть ровно 2 треугольника, прилегающих к нему. Таким образом, каждый четырехугольник в триангуляции порождается ребром и двумя вершинам, находящимися напротив ребра в прилегающих треугольниках [картинка]. Так как по ребру и двум вершинам восстанавливаются два треугольника и их смежность, то по всем таким структурам мы сможем восстановить триангуляцию. Предлагается хранить их в множестве и выполнять поиск по ребру (упорядоченной паре вершин).




Приступим к алгоритму:

Идея заметающей прямой заключается в том, что все точки сортируются, а затем по очереди обрабатываются

1) Отсортируем все точки вдоль некоторой прямой (для простоты по координате х)

2) Построим треугольник на первых 3 точках

Далее для каждой следующей точки будем выполнять шаги, сохраняющие инвариант, что имеется триангуляция Делоне для уже добавленных точек и, соответственно, МВО для них.

3) Добавим треугольники, образованные видимыми ребрами и самой точкой (то есть добавим ребра из рассматриваемой точки во все концы видимых ребер)

4) Проверим на условие Делоне все четырехугольники, порожденные видимыми ребрами. Если где-то условие не выполнилось, то перестроим триангуляцию в четырехугольнике (напоминаю, что их всего две) и рекурсивно запустим проверку для четырехугольников, порожденных ребрами текущего четырехугольника (ибо только в них после изменения условие Делоне могло нарушиться) [гифка]


Замечание: в шаге 4 при рекурсивном запуске можно не проверять четырехугольники, порожденные ребрами, исходящими из рассматриваемой на данной итерации точки (их всегда два из четырех), ибо они являются невыпуклыми. Далее будем считать, что при каждом перестроении выполняется только 2 рекурсивных запуска


Осталось понять, как эффективно находить видимые ребра. Заметим, что предыдущая добавленная точка S находится в МВО на текущей итерации, так как имеет наибольшую координату х, а также видима для текущей точки. Тогда, замечая, что концы видимых ребер образуют непрерывную цепочку, нам достаточно идти от точки S в обе стороны по МВО и собирать ребра, пока они видимы (она проверяется с помощью векторного произведения). Таким образом удобно хранить МВО как двусвязный список, на каждой итерации удаляя видимые ребра и добавляя 2 новых из рассматриваемой точки [картинка]


### Корректность алгоритма


Чтобы доказать корректность алгоритма, достаточно доказать сохранение инварианта в шагах 3 и 4. После шага 3, очевидно, получится некоторая триангуляция текущего множества точек. В процессе выполнения шага 4 все четырехугольники, не удовлетворяющие условию Делоне, находятся в стеке рекурсии (следует из описания шага 4), а значит, по окончании шага 4 все четырехугольники удовлетворяют условию Делоне, то есть действительно построена триангуляция Делоне. Тогда осталось доказать, что процесс в шаге 4 когда-нибудь закончится. Это следует из того, что все ребра, добавленные при перестроении, исходят из текущей рассматриваемой вершины  (то есть на шаге i их не больше, чем i - 1) и из того, что после добавления этих ребер мы не будем рассматривать четырехугольники, порожденные ими (см. предыдущее замечание), а значит, добавим ровно один раз.


### Временная сложность


В среднем на множестве стандартных распределений алгоритм работает линейно-логарифмическое время, то есть O( n ) или O( nlogn ) в зависимости от типа сортировки. В худшем случае имеет место оценка O( n^2 ).


Для начала покажем, что время, суммарно затраченное на поиск видимых граней, есть O( n ). Заметим, что на каждой итерации время, затраченное на поиск новой видимой грани, - O( 1 ), и после итерации все видимые грани попадают внуть МВО, то есть мы их больше никогда не найдем. Также мы добавляем в МВО новые 2 ребра. Таким образом, всего в меняющейся на протяжении алгоритма МВО побывает не более 2 * n ребер, значит, и различных видимых ребер будет не более 2 * n, то есть на их поиск мы затратим время O( n ).


Далее, известно, что на многих распространенных распределениях среднее время, затраченное на один рекурсивный вызов из шага 4, составляет O( 1 ), то есть суммарно снова получается O( n ).


Значит, при условии, что сортировка работает не менее чем за линейное время, получаем, что временная сложность алгоритма совпадает со сложностью сортировки.

В худшем случае на i-ом шаге происходит i - 1 рекурсивный вызов, то есть, суммируя по всем i, получаем асимптотику в худшем случае O( n^2 )
[табличка с моими временными результатами]


### Сравнение с итеративным алгоритмом построения триангуляции Делоне с использованием kD-дерева


