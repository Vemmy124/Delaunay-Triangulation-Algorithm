# Алгоритм триангуляции Делоне методом заметающей прямой

Доброго времени суток!


В этой статье я подробно опишу алгоритм, который у меня получился в результате использования идеи "заметающей прямой" для
построения триангуляции Делоне на плоскости. В нем есть несколько идей, которые я нигде не встречал, когда читал статьи про триангуляцию.
Возможно, кто-то тоже найдет их необычными. Я постараюсь сделать все в лучших традициях и включить в рассказ следующие вещи: описание используемых структур данных, описание шагов алгоритма, доказательство корректности, временные оценки, а также сравнение с итеративным алгоритмом, использующим kD-дерево.


### Определения и постановка задачи
Говорят, что на множестве точек на плоскости задана триангуляция, если некоторые пары точек соединены ребром, а любая конечная грань в получившемся графе образует треугольник [картинка]


Триангуляцией Делоне называется такая триангуляция, в которой для любого треугольника верно, что внутри описанной около него окружности не находится точек из исходного множества. 

Замечание: для заданного множества точек, в котором никакие 4 точки не находятся на одной окружности, существует ровно одна триангуляция Делоне


Пусть на множестве точек задана триангуляция. Будем говорить, что некоторое подмножество точек удовлетворяет условию Делоне, если триангуляция, ограниченная на это подмножество, является триангуляцией Делоне для него. 


Замечание: проверка условия Делоне для всех точек, образующих выпуклый четырехугольник в триангуляции, гарантирует то, что она является триангуляцией Делоне. 


Замечание 2: для выпуклого четырехугольника существует ровно 2 возможные триангуляции (одна из которых является триангуляцией Делоне)


Замечание 3: для невыпуклых четырехугольников условие Делоне всегда выполнено. 


Задача собственно заключается в том, чтобы для заданного множества точек построить триангуляцию Делоне

### Описание алгоритма
Для начала введем следующее определение:


Пусть задана минимальная выпуклая оболочка (далее МВО) конечного множества точек (ребра, соединяющие некоторые из точек так, чтобы они образовывали многоугольник, содержащий все точки множества) и точка A, лежащая вне оболочки. Тогда ребро называется видимым для точки А, если отрезки, соединяющие его концы с точкой А не пересекают другие ребра МВО [картинка]. 


Замечание: контур триангуляции Делоне является МВО для точек, на которых построена.


Думаю, здесь стоит сделать пару замечаний, чтобы понять, как хранить триангуляцию. Есть некоторые стандартные способы, неплохо описанные в книге Скворцова [1]. Ввиду специфики алгоритма, я предложу свой вариант. Так как хочется проверять 4-угольники на условие Делоне, то рассмотрим их строение. Каждый 4-угольник в триангуляции представляет из себя 2 треугольника, имеющих общее ребро. У каждого ребра есть ровно 2 треугольника, прилегающих к нему. Таким образом, каждый четырехугольник в триангуляции порождается ребром и двумя вершинам, находящимися напротив ребра в прилегающих треугольниках [картинка]. Так как по ребру и двум вершинам восстанавливаются два треугольника и их смежность, то по всем таким структурам мы сможем восстановить триангуляцию. Предлагается хранить их в множестве и выполнять поиск по ребру (упорядоченной паре вершин).




Приступим к алгоритму:

Идея заметающей прямой заключается в том, что все точки сортируются, а затем по очереди обрабатываются

1) Отсортируем все точки вдоль некоторой прямой (для простоты по координате х)

2) Построим треугольник на первых 3 точках

Далее для каждой следующей точки будем выполнять шаги, сохраняющие инвариант, что имеется триангуляция Делоне для уже добавленных точек и, соответственно, МВО для них.

3) Добавим треугольники, образованные видимыми ребрами и самой точкой (то есть добавим ребра из рассматриваемой точки во все концы видимых ребер)

4) Проверим на условие Делоне все четырехугольники, порожденные видимыми ребрами. Если где-то условие не выполнилось, то перестроим триангуляцию в четырехугольнике (напоминаю, что их всего две) и рекурсивно запустим проверку для четырехугольников, порожденных ребрами текущего четырехугольника (ибо только в них после изменения условие Делоне могло нарушиться) [гифка]


Замечание: в шаге 4 при рекурсивном запуске можно не проверять четырехугольники, порожденные ребрами, исходящими из рассматриваемой на данной итерации точки (их всегда два из четырех), ибо они являются невыпуклыми. Далее будем считать, что при каждом перестроении выполняется только 2 рекурсивных запуска


Чтобы доказать корректность алгоритма, достаточно доказать сохранение инварианта в шагах 3 и 4. После шага 3, очевидно, получится некоторая триангуляция текущего множества точек. В процессе выполнения шага 4 все четырехугольники, не удовлетворяющие условию Делоне, находятся в стеке рекурсии (следует из описания шага 4), а значит, по окончании шага 4 все четырехугольники удовлетворяют условию Делоне, то есть действительно построена триангуляция Делоне. Тогда осталось доказать, что процесс в шаге 4 когда-нибудь закончится. Это следует из того, что все ребра, добавленные при перестроении, исходят из текущей рассматриваемой вершины  (то есть на шаге n их не больше, чем n - 1) и из того, что после добавления этих ребер мы не будем рассматривать четырехугольники, порожденные ими (см. предыдущее замечание), а значит, добавим ровно один раз.
